# 项目介绍

本项目是一个Java设计模式的实战教程,包含了23中GoF设计模式的Java实现以及UML基础知识和软件设计的七大原则说明内容.适合初识设计模式的程序员学习.通过本项目,你可以了解到如何进行架构设计,代码解耦合,系统重构等思想.

# 一.UML

## 	1.1 UML的定义

​               统一建模语言(Unified Modeling Language, UML)是一种面向对象系统的产品进行说明,可视化和编制文档的标准语言,是非专利的第三代建模和规约语言.UML是一种面向对象设计的建模工具,是在开发阶段说明,可视化,构建和书写一个面向对象软件密集系统的制品的开放方法,但独立于任何具体的程序设计语言.



## 	1.2 UML应用场景

​		UML最佳应用是工程实践,在对大规模,复杂系统进行建模方面,特别是软件架构层次,已经被验证有效,UML模型大多以图表的方式表现出来.一份典型的建模图表通常包含几个块或框,连接线和作为模型附加信息的文本.这些虽简单却非常重要,在UML规则中相互联系和扩展.

## 	1.3 UML基本构件

​		UML建模的核心是模型,模型是实现的简化,真实系统的抽象.UML提供了系统的设计蓝图.当给软件系统建模时,需要采用通用的符号语言,这种描述模型所使用的语言被称为建模语言.在UML中,所有的描述由事务,关系和图这些构件组成.

​		![](images/UML.png)

### 	1.3.1 事物

​		事物是抽象化的最终结果,分为结构事物,行为事物,分组事物和注释事物.

#### 		1) 结构事物

​		结构事物是模型中的静态部分,用以呈现概念或实体的表现元素

| 事物                 | 解释                                                         | 图例                           |
| -------------------- | ------------------------------------------------------------ | ------------------------------ |
| 类(Class)            | 具有相同属性,方法,关系和语义的对象集合                       | ![](images/class.png)          |
| 接口(Interface)      | 指一个类或构件的一个服务的操作集合,它仅仅定义了一组操作规范,并没有给出这组操作的具体实现 | ![](images/interface.png)      |
| 用例(User Case)      | 指对一组动作序列的描述,系统执行这些动作将产生一个对特定的参与者(Actor)有价值且可观察的结果 | ![](images/User-Case.png)      |
| 协作(Collaborations) | 定义元素之间的相互作用                                       | ![](images/Collaborations.png) |
| 组件(Component)      | 描述物理系统的一部分                                         | ![](images/Component.png)      |
| 活动类(Active Class) | 指对象有一个或多个进程或线程.活动类和类很相像,只是它的对象代表的元素行为和其他元素是同时存在的 | ![](images/ActiveClass.png)    |
| 节点(Node)           | 定义为运行时存在的物理元素                                   | ![](images/Node.png)           |

#### 		2) 行为事物

​		行为事物是指UML建模中的动态部分.

| 事物                  | 解释                       | 图例                         |
| --------------------- | -------------------------- | ---------------------------- |
| 交互(Interaction)     | 包括一组元素之间的消息交换 | ![](images/Interaction.png)  |
| 状态机(State Machine) | 由一系列对象的状态组成     | ![](images/StateMachine.png) |

#### 		3) 分组事物

​		目前只有一种分组事物,即包.包纯粹是概念上的,只存在于开发阶段,结构事物,行为事物甚至分组事物都有可能放在一个包中.

| 事物        | 解释                | 图例                    |
| ----------- | ------------------- | ----------------------- |
| 包(Package) | UML中唯一的组织机制 | ![](images/Package.png) |

#### 		4) 注释事物

​		注释事物是解释UML模型元素的部分.

| 事物 | 解释                | 图例                 |
| ---- | ------------------- | -------------------- |
| 注释 | 用于解析说明UML元素 | ![](images/Note.png) |

### 		1.3.2 关系

UML将事物之间的联系归纳为6种,并用对应的图形类表示.

| 事物关系             | 说明                                                         | 图例                           |
| -------------------- | ------------------------------------------------------------ | ------------------------------ |
| 关联(Association)    | 表示一种拥有的关系,具有方向性.如果一<br/>个类单方向地访问另一个类,则称为单向<br/>关联;如果两个类的想可以互相访问,则称为<br/>双向关联,一个对象能访问关联对象的数目叫作"多重性". | ![](images/Assocation.png)     |
| 聚合(Aggregate)      | 表示整体与部分的关系.当某个实体聚合成<br/>另一个实体时,该实体还可以是另一个实体的部分. | ![](images/Aggregate.png)      |
| 组合(Combination)    | 表示整体与部分的关系,组合比聚合<br/>更加严格.当某个实体组合成另一个<br/>实体时,二者具有相同的生命周期,例如<br/>手臂和人之间是组合关系. | ![](images/Combination.png)    |
| 泛化(Generalization) | 表示一个更泛化的元素与一个更具体的元素<br/>之间的关系,与继承是同一个概念. | ![](images/Generalization.png) |
| 实现(Realization)    | 表示类与接口的关系,类实现接口.                               | ![](images/Realization.png)    |
| 依赖(Dependency)     | 如果一个类的改动会影响另一个<br/>类,则两个类之间存在依赖关系,一般而言,依赖是单向的. | ![](images/Dependency.png)     |

### 		1.3.3 图

UML2.0一共有13种图(UML1.5定义了9种,UML2.0增加了4种),分别是类图,对象图,构件图,部署图,活动图,状态图,用例图,时序图,协作图9种,以及包图,组合结构图,时间图,交互概览图4种.

| 图名称                                    | 解释                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| 类图(Class Diagrams)                      | 用于定义系统种的类                                           |
| 对象图(Object Diagrams)                   | 类图的一个实例,描述了系统在具体时间点上所包含的对象及各个对象之间的关系 |
| 构件图(Component Diagrams)                | 一种特殊的UML图,描述系统的静态实现视图                       |
| 部署图(Deployment Diagrams)               | 定义系统中软硬件的物理体系结构                               |
| 活动图(Activity Diagrams)                 | 用来描述满足用例要求所要进行的活动及活动时间的约束关系       |
| 状态图(State Chart Diagrams)              | 用来描述类的对象的所有可能的状态和时间发生时,状态的转移条件  |
| 用例图(Usecase Diagrams)                  | 用来描述用户的需求,从用户的角度描述系统的功能,并指出各功能的执行者,强调谁在使用系统,系统为执行者完成哪些功能 |
| 时序图(Sequence Diagrams)                 | 描述对象之间的交互顺序,着重体现对象间消息传递的时间顺序,强调对象之间消息的发送顺序,同时显示对象之间的交互过程 |
| 协作图(Collaboration Diagrams)            | 描述对象之间的合作关系,更侧重向用户对象说明哪些对象有消息的传递 |
| 包图(Package Diagrams)                    | 对构成系统的模型元素进行分组整理的图                         |
| 组合结构图(Composite Structure Diagrams)  | 表示类或者构建内部结构的图                                   |
| 时间图(Timing Diagrams)                   | 用来显示随时间变化,一个或多个元素的值或状态的更改,也显示时间控制事件之间的交互及管理它们的时间和期限约束 |
| 交互概览图(Interaction Overview Diagrams) | 用活动图来表示多个交互之间的控制关系的图                     |



# 二.设计模式常用UML图

## 2.1 类图

​	在UML 2.0的13种图中,类图(Class Diagrams)是使用频率最高的UML图之一.类图描述系统中的类,以及各个类之间的关系的静态视图,能够让我们在正确编写代码之前对系统有一个全面的认识.类图是一种模型类型,确切地说,是一种静态模型类型.类图表示类,接口和它们之间的协作关系,用于系统设计阶段.

### 2.1.1 继承关系

​	在继承(Generalization,又叫作泛化)关系中,子类继承父类的所有的功能,父类所具有的属性,方法,子类都应该有.除了与父类一致的信息,子类中还包括额外的信息.

### 2.1.2 实现关系

​	接口(包括抽象类)是方法的集合,在实现(Realization)关系中,类实现了接口,类中的方法实现了接口声明的所有方法.

### 2.1.3 组合关系

​	组合(Combination)关系表示类之间整体与部分的关系,整体与部分有一致的生存期.一旦整体对象不存在,部分对象也将不存在,整体和部分是同生共死的关系.

### 2.1.4 聚合关系

​	聚合(Aggregate)关系表示类之间整体与部分的关系,成员对象是整体对象的一部分,但是成员对象可以脱离整体对象独立存在.例如,公交车司机和工作服,工作帽是整体与部分的关系,但是可以分开,没有共同的声明周期.工作服,工作帽可以穿,戴在别的司机身上,公交车司机也可以换别人的工作服,工作帽.

### 2.1.5 关联关系

​	关联(Association)关系是类与类之间最常用的一种关系,表示一类对象与另一类对象之间有联系.组合,聚合也属于关联关系只是关联关系的类间关系比其他两种关系要弱.

​	关联关系有4种,双向关联,单向关联,自关联,多重性关联.例如汽车和司机,一辆汽车对应特定的司机,一个司机也可以开多辆车.

​	在多重性关联关系中,可以直接在关联直线上增加一个数字,表示与之对应的另一个类的对象的个数,具体含义如下表所示:

| 表示方式 | 含义                |
| -------- | ------------------- |
| 1..1     | 仅一个              |
| 0..*     | 零个或多个          |
| 1..*     | 一个或多个          |
| 0..1     | 没有或只有一个      |
| m..n     | 最少m,最多n个(m<=n) |

### 2.1.6 依赖关系

​	依赖(Dependency)关系是一种"使用"关系,特定事物的改变有可能会影响到使用该事物的其他事物,当需要表示一个事物使用另一个事物时,使用依赖关系.在大多数情况下,依赖关系体现在某个类的方法使用另一个类的对象作为参数.例如: 汽车依赖汽油,如果没有汽油,则汽车无法行驶.

​	在这6种关系中,组合,聚合和关联的代码结构一样,可以从关系的强弱来理解,各类关系从强到弱依次是: 继承 > 实现 > 组合 > 聚合 > 关联 > 依赖.

### 2.1.7 类关系记忆技巧

| 分类      | 箭头特征                                     | 记忆技巧                                                     |
| --------- | -------------------------------------------- | ------------------------------------------------------------ |
| 箭头方向  | 从子类指向父类                               | 1. 定义子类需要通过extends关键字指定父类<br/> 2. 子类一定是知道父类的定义的,但父类并不知道子类的定义<br/> 3. 只有知道对方信息时才能指向对方<br/> 4. 箭头的方向是从子类指向父类 |
| 继承/实现 | 用线条连接两个类空心三角形箭头表示继承或实现 | 实线表示继承,是is-a的关系,表示扩展,不虚,很结实<br/>虚线表示实现,虚线代表"虚"无实体 |
| 关联/依赖 | 用线条连接两个类;<br/>普通箭头表示关联或依赖 | 1. 虚线表示依赖关系,临时用一下,若即若离,虚无缥缈,若有若无<br/> 2. 表示一种使用关系,一个类需要借助另一个类来实现功能<br/> 3. 一般一个类将另一个类作为参数使用,或作为返回值<br/> 4. 实线表示关联关系,关系稳定,实打实的关系,"铁哥们" <br/> 5. 表示一个类对象和另一个类对象有关联<br/> 6. 通常一个类中有另一个类对象作为属性 |
| 组合/聚合 | 用菱形表示;<br/>像一个盛东西的器皿           | 1. 聚合:空心菱形,代表空器皿里可以放很多相同的东西,聚集在一起(箭头方向所指的类)<br/>2. 整体和局部的关系,两者有独立的声明周期,是has-a的关系<br/>3. 弱关系,消极的词,弱-空<br/>4. 组合,实心菱形,代表器皿已经有实体结构的存在,生死与共<br/>5. 整体与局部的关系,和聚合关系对比,关系更加强烈,两者具有相同的生命周期,contains-a的关系<br/>6. 强关系,积极的词,强-满. |


## 2.2 时序图

​	时序图(Sequence Diagrams)描述对象之间消息的发送顺序,强调时间顺序.时序图是一个二维图,横轴表示对象,纵横表示时间,消息在各对象之间横向传递,按照时间顺序纵向排列,用箭头表示消息,用竖虚线表示对象生命线.

### 2.2.1 时序图的作用

​	(1) 展示对象之间交互的顺序.将交互行为建模为消息的传递,通过描述消息如何在对象间发送和接收来动态展示对象之间的交互.

​	(2) 相对于其他的UML图,时序图更强调交互的时间顺序.

​	(3) 可以直观地描述并发进程. 

### 2.2.2 时序图组成元素

​	时序图组成元素主要包括角色(Actor),对象(Object),生命线(Lifeline),控制焦点(Focus of Control)和消息(Message),其具体解释如下表所示:

| 元素     | 解释                                                         | 图例                           |
| -------- | ------------------------------------------------------------ | ------------------------------ |
| 角色     | 系统角色,可以是人,机器,其他系统,子系统                       | ![](images/role.png)           |
| 对象     | 1. 对象的三种命名方式:<br/>  第一种方式包括对象名和类名<br/>  第二种方式只显示类名,即表示它是一个匿名对象<br/>  第三种方式只显示对象名不显示类名<br/> 2. 命名方式的选择<br/>  三种命名方式均可,那种最容易让阅读该时序图的人理解,就选哪种<br/> 3. 对象的排列顺序<br/>  对象的左右顺序并不重要,但是为了作图清晰整洁,通常应遵循以下两个原则,把交 互频繁地对象尽可能靠拢,把初始化整个交互活动的对象放置在最左侧 | ![](images/Object.png)         |
| 生命线   | 在时序图中表示为从对象图标向下延伸的一条虚线,表示对象存在的时间 | ![](images/life-line.png)      |
| 控制焦点 | 又被称为激活期,表示时间段的符号,表示在这个时间段内对象将执行相应的操作可以理解为Java中一对大括号中的内容 | ![](images/FocusOfControl.png) |
| 消息     | 消息一般分为同步消息(Synchronous Message),异步消息(Asynchronous Message)和返回消息(Return Message)<br/> 1. 消息发送者把控制传递给消息接收者,然后停止活动,等待消息接收者放弃或者返回控制,用来表示同步的意义.<br/> 2. 消息发送者通过消息把信号传递给消息接收者,然后继续自己的活动,不等待接收者返回消息或者控制.异步消息的接收者和发送者是并发工作的.<br/> 3. 返回消息表示从过程调用返回 | ![](images/Interaction.png)    |



### 2.2.3 时序图组合片段

​	组合片段(Combined Fragments)用来解决交互执行的条件和方式.它允许在时序图中直接表示逻辑组件,用于通过指定条件或子进程的应用区域,为任何生命线的任何部分定义特殊条件和子进程.组合片段共有13种,名称及含义如下:

| 类型     | 名称   | 说明                                                         |
| -------- | :----- | ------------------------------------------------------------ |
| Alt      | 抉择   | 包含一个片段列表,这些片段包含备选消息序列.在任何场合下只发生一个序列.可以在每个片段中都设置一个临界来指示该片段可以运行的条件.else的临界指示其他临界都不为true时应运行的片段.如果所有临界都为false并且没有else,则不执行任何片段. |
| Opt      | 选项   | 包含一个可能发生或不可能发生的序列.可以在临界中指定序列发生的条件. |
| Loop     | 循环   | 片段重复一定次数.可以在临界中指示片段重复的条件.Loop组合片段具有Min和Max属性,它们指示片段可以重复的最小值和最大次数.默认值是无限制. |
| Break    | 中断   | 如果执行此片段,则放弃序列的其余部分.可以使用临界来指示发生中断的条件. |
| Par      | 并行   | 并行处理.片段中的事件可以交错.                               |
| Critical | 关键   | 用来Par或Seq片段中.指示此片段中的消息不得与其他消息交错.     |
| Seq      | 弱顺序 | 有两个或更多操作数片段.涉及同一生命线的消息必须按片段的顺序发生.如果消息涉及的生命线不同,则来自不同片段的消息可能会并行交错. |
| Strict   | 强顺序 | 有两个或更多操作数片段,这些片段必须按给定顺序发生.           |
| Consider | 考虑   | 指定此片段描述的消息列表.其他消息可发生在运行的系统中,但对此描述来说意义不大.在Message属性中键入该列表. |
| Ignore   | 忽略   | 指定此片段未描述的消息列表.这些消息可发生在运行的系统中,但对此描述来说意义不大.在Message属性中键入该列表. |
| Assert   | 断言   | 操作数片段指定唯一有效的序列.通常在Consider或Ignore片段中.   |
| Neg      | 否定   | 此片段中显示的序列不得发生.通常在Consider或Ignore片段中.     |



# 三.七大软件架构设计原则

## 3.1 开闭原则

​	开闭原则(Open-Closed Principle,OCP)指一个软件实体如类,模块和函数应该对扩展开放,对修改关闭.所谓开闭,也正是对扩展和修改两个行为的一个原则.强调的是用抽象构建框架,用实现扩展细节,可以提高软件系统的可复用性及可维护性.开闭原则是面向对象设计中最基础的设计原则.它指导我们如何建立稳定灵活的系统,例如版本更新,我们尽可能不修改源码,但是可以增加新的功能.

​	在现实生活中,开闭原则也有体现.比如,很多互联网公司都实行弹性制工作时间,规定每天工作8个小时.意思就是说,对于每天工作8小时这个规定是关闭的,但是什么时候来,什么时候走是开放的.早来早走,晚来晚走.

​	实现开闭原则的核心思想就是面向抽象编程.



## 3.2 依赖倒置原则

​	依赖倒置原则(Dependency Inversion Principle,DIP)指设计代码结构时,高层模块不应该依赖底层模块,二者都应该依赖其抽象.抽象不应该依赖细节,细节应该依赖抽象.通过依赖倒置原则,可以降低类与类之间的耦合性,提高系统的稳定性,提高代码的可读性和可维护性,并降低修改程序带来的风险.



## 3.3 单一职责原则

​	单一职责原则(Simple Responsibility Principle,SRP)指不要存在一个以上导致类变更的原因.假设有一个Class负责两个职责,一旦发生需求变更,修改其中一个职责的逻辑代码,有可能会导致另一个职责的功能发生故障.这样一来,这个Class就存在两个导致类变更的原因.如何解决这个问题?我们就要分别用两个Class来实现两个职责,进行解耦.后期需求变更维护互不影响.这样的设计,可以降低类的复杂度,提高类的可读性,提高系统的可维护性,降低变更引起的风险.总体来说就是一个Class,Interface,Method只负责一项职责.



## 3.4 接口隔离原则

​	接口隔离原则(Interface Segregation Principle, ISP)指用多个专门的接口,而不使用单一的总接口,客户端不应该依赖它不需要的接口.这个原则知道我们在设计接口时,应当注意以下几点.

 	1. 一个类对另一个的依赖应该简历在最小接口上
 	2. 建立单一接口,不要建立庞大臃肿的接口
 	3. 尽量细化接口,接口中的方法尽量少(不是越少越好,一定要适度)

接口隔离原则符合"高聚合,低耦合"的设计思想,使得类具有很好的可读性,可扩展性和可维护性.在设计接口的时候,要多花时间思考,要考虑业务模型,包括还要对以后可能发生变更的地方做一些预判.所以,在实际开发中,我们对抽象,业务模型的理解是非常重要的.



## 3.5 迪米特法则

​	迪米特法则(Law of Demeter, LoD)又叫作最少知道原则(Least Knowledge Principle, LKP),指一个对象应该对其他对象保持最少的了解,尽量降低类与类之间的耦合.迪米特法则主要强调和朋友交流,不和陌生人说话.出现在成员变量,方法的输入和输出参数中的类都可以被称为成员朋友,而出现在方法体内部的类不属于朋友类.



## 3.6 里氏替换

​	里氏替换原则(Liskov Substitution Principle, LSP)指如果对每一个类型为T1的对象O1,都有类型为T2的对象O2,使得以T1定义的所有程序P在所有对象O1都替换成O2时,程序P的行为没有发生变化,那么类型T2是类型T1的子类型.

​	定义看上去比较抽象,重新解释一下,可以理解为一个软件实体如果适用于一个父类,则一定使用于其子类,所有引用父类的地方必须能透明地使用其子类对象,子类对象能够替换父类对象,而程序逻辑不变.也可以理解为,子类可以扩展父类的功能,但不能改变父类原有的功能.根据这个理解,我们对里氏替换原则的定义总结如下:

 	1. 子类可以实现父类的抽象方法,但不能覆盖父类的非抽象方法
 	2. 子类中可以增加自己的特有方法
 	3. 当子类的方法重载父类的方法时,方法的前置条件(即犯法的输入参数)要比父类的方法更加宽松
 	4. 当子类的方法实现父类的方法时(重写/重载或实现抽象方法),方法的后置条件(即方法的输出/返回值)要比父类的方法更严格或相等.



## 3.7 合成复用原则

​	合成复用原则(Composite/Aggregate Reuse Principle, CARP)指尽量使用对象组合(has-a)或对象集合(contains-a)的方式实现代码复用,而不是用继承关系达到代码复用的目的.合成复用原则可以使系统更加灵活,降低类与类之间的耦合度,一个类的变化对其他的类造成的影响相对较小.

​	继承,又称为白箱复用,相当于把所有实现细节暴露给子类.组合/聚合又被称为黑箱复用,对类似以外的对象是无法获取实现细节.我们要根据具体的业务场景来做代码设计,其实也都需要遵守面向对象编程(Object Oriented Programming, OOP)模型.



## 3.8 软件架构设计原则总结

| 设计原则     | 一句话概括                                        | 目的                                     |
| ------------ | ------------------------------------------------- | ---------------------------------------- |
| 开闭原则     | 对扩展开放,对修改关闭                             | 降低维护带来的风险                       |
| 依赖倒置原则 | 高层不应该依赖低层                                | 更利于代码结构的升级扩展                 |
| 单一职责原则 | 一个类只干一件事                                  | 便于理解,提高代码可读性                  |
| 接口隔离原则 | 一个接口只干一件事                                | 功能解耦,高聚合,低耦合                   |
| 迪米特法则   | 不知道的不要知道                                  | 只和朋友交流,不和陌生人说话,减少代码臃肿 |
| 里氏替换原则 | 子类重写方法功能发生改变,不应该影响父类方法的含义 | 防止继承泛滥                             |
| 合成复用原则 | 尽量使用组合实现代码复用,而不适用继承             | 降低代码耦合                             |



# 四.创建型设计模式

## 	4.1 简单工厂模式

### 	4.1.1 简单工厂模式定义

​	简单工厂模式(Simple Factory Pattern)又叫作静态工厂方法模式(Static Factory Method Pattern),简单来说,简单工厂模式有一个具体的工厂类,可以生成多个不同的产品,属于创建型设计模式.简单工厂模式不在GoF23种设计模式之列.

### 	4.1.2 简单工厂模式应用场景

​	对于产品种类相对较少的情况,考虑使用简单工厂模式可以很方便地创建所需产品.使用简单工厂模式的客户端只需要传入工厂类的参数,不需要关心如何创建对象的逻辑.

### 	4.1.3 简单工厂模式UML类图

​	![1643260529665](images/simple-factory.png)

简单工厂模式主要包含3个角色:

1. **简单工厂(SimpleFactory)**: 是简单工厂模式的核心,负责实现创建所有实例的内部逻辑.工厂类的创建产品类的方法可以被外界直接调用,创建所需的产品对象.
2. **抽象产品(IProduct)**: 是简单工厂创建的所有对象的父类,负责描述所有实例共有的公共接口.
3. **具体产品(Product)**: 是简单工厂模式的创建目标.

### 4.1.4 扩展

#### 	简单工厂模式优点

​	简单工厂模式的结构简单,调用方便,对于外界给定的信息,可以很方便地创建出相应的产品,工厂和产品的职责区分明确.

#### 	简单工厂模式的缺点

​	简单工厂模式的工厂类单一,负责所有产品的创建,但产品基数增多时,工厂类代码会非常臃肿,违背高聚合原则.



## 4.2 工厂方法模式

### 	4.2.1 工厂方法模式定义

​	工厂方法模式(Factory Method Pattern)又叫作多态性工厂模式,指定义一个创建对象的接口,但由实现这个接口的类来决定实例化哪个类,工厂方法把类的实例化推迟到子类中进行.

> **Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.**	

​	在工厂方法模式中,不在由单一的工厂类生产产品,而是由工厂类的子类实现具体产品的创建.因此,当增加一个产品时,只需要增加一个相应的工厂类的子类,实现生产这种产品,便可以解决简单工厂生产太多导致其内部代码臃肿(switch... case分支过多)的问题,也符合开闭原则.

### 	4.2.2 工厂方法使用场景

 	1. 创建对象需要大量的重复代码
 	2. 客户端(应用层)不依赖产品类的实例如何被创建,实现等细节
 	3. 一个类通过其子类来指定创建哪个对象



### 	4.2.3 工厂模式的UML类图

![1643261594547](images/factory-method.png) 

工厂方法模式主要包含4个角色

1. **抽象工厂(IFactory)**: 是工厂方法模式的核心,与应用程序无关.任何模式中创建的抽象工厂类必须实现这个接口.
2. **具体工厂(ConcreteFactory)**: 是实现抽象工厂接口的具体工厂类,包含与应用程序密切相关的逻辑,并且被应用程序调用用以创建产品对象.
3. **抽象产品(IProduct)**: 是工厂方法模式所创建的对象的超类,也就是产品对象的共同类或共同拥有的接口.
4. **具体产品(ConcreteProduct)**: 这个角色实现了抽象产品角色所定义的接口.某具体产品由专门的具体分工厂创建,它们之间往往一一对应.



### 4.2.4 工厂方法模式扩展

#### 	工厂方法模式优点

   	1. 灵活性强,对新产品的创建,只需要多写一个相应的工厂类.
   	2. 典型的解耦框架.高层模块只需要知道产品的抽象类,无须关心其他实现类,满足迪米特法则,依赖倒置原则和里氏替换原则.

#### 	工厂方法模式缺点

1. 容易类爆炸,增加复杂度.
2. 增加了系统的抽象性和理解难度.
3. 抽象产品只能生产一种产品,此弊端可使用抽象工厂模式解决.



## 4.3 抽象工厂模式

### 4.3.1 抽象工厂模式定义

​	抽象工厂模式(Abstract Factory Method)指提供一个创建一系列或相互依赖对象的接口,无须指定它们具体的类.意思是客户端不必指定产品的具体类型,创建多个产品族中的产品.

> **Provide an interface for creating families of related or dependent objects without specifying their concrete classes;**

​	在抽象工厂模式中,客户端(应用层)不依赖产品类实例如何被创建,实现等细节,强调一系列相关的产品对象(属于同一产品族)一起创建对象,需要大量重复的代码.

​	需要提供一个产品类的库,所有的产品以同样的接口实现,从而使客户端不依赖具体实现.

### 4.3.2 抽象工厂模式使用场景

​	抽象工厂模式适用于需要生成产品族的情景.抽象产品类内部提供了多个其他抽象产品,抽象工厂类定义了产品的创建接口通过具体的工厂子类,就可以生产相应的产品族对象,供用户端使用.

### 4.3.3 抽象工厂模式的UML类图

![1645242399431](images/abstract-factory.png)

抽象工厂主要包含4个角色:

1. **抽象工厂(IFactory)**: 声明创建抽象产品对象的一个操作接口.
2. **具体工厂(ConcreteFactory)**: 实现创建具体产品对象的操作
3. **抽象产品(IProduct)**: 为一类产品对象声明一个接口
4. **具体产品(ConcreteProduct)**: 定义一个将被相应的具体工厂创建的产品对象**IProduct**接口

### 4.3.4 抽象工厂模式扩展

#### 抽象工厂模式优点

1. 当需要产品族时,抽象工厂可以保证客户端始终只有同一个产品的产品族
2. 抽象工厂增强了程序的可扩展性,对于新产品族的增加,只需要实现一个新的具体工厂即可,不需要对已有代码进行修改,符合开闭原则.

#### 抽象工厂模式缺点

1. 规定了所有可能被创建的产品集合,产品族中扩展新的产品困难,需要修改抽象工厂的接口.
2. 增加了系统的抽象性和理解难度



## 4.4 单例模式

### 4.4.1 单例模式定义

​	单例模式(Singleton Pattern)指确保一个类在任何情况下都绝对只有一个实例,并提供一个局部访问点,属于创建型设计模式.

> **Ensure a class has only one instance, and provide a global point of access to it.**

### 4.4.2 单例模式使用场景

​	单例模式在现实生活中的应用非常广泛,例如公司CEO,部门经理等都属于单例模式.**J2EE**标准中的**ServletContext**和**ServletContextConfig**,**Spring**框架应用中的**ApplicationContext**,数据库中的连接池都是单例模式.对于**Java**来说单例模式可以保证在一个**JVM**中只存在单一实例.单例模式的应用场景主要有以下几个方面:

1. 需要频繁创建的一些类,使用单例模式可以降低系统的内存压力减少GC.
2. 某些类创建实例时占用资源较多,或实例化耗时较长,且经常使用.
3. 频繁访问数据库或文件的对象.
4. 对于一些控制硬件级别的操作,或者从系统上来讲应当是单一控制逻辑的操作,如果有多个实例则,系统会完全乱套.

### 4.4.3 单例模式UML类图

![1645266984083](images/singleton.png)

Singleton类被称为单例类,通过隐藏构造方法,在内部初始化一次,并提供一个全局的访问点.

### 4.4.4 单例模式扩展

#### 单例模式优点

1. 单例模式可以保证内存里只有一个实例,减少了内存的开销
2. 可以避免对资源的多重占用
3. 单例模式可以设置全局访问点,可以优化和共享资源的访问

#### 单例模式缺点

1. 单例模式一般没有接口,扩展困难.如果要扩展,则除了修改原来的代码,没有第二种途径,违背开闭原则.
2. 在并发测试中,单例模式不利于代码调试,在测试过程中,如果单例中的代码没有执行完,也不能模拟生成一个新的对象.
3. 单例模式的功能代码通常写在一个类中,如果功能设计不合理,则容易违背单一职责原则.



## 4.5 原型模式

### 4.5.1 原型模式定义

​	原型模式(Prototype Pattern)指原型实例指定创建对象的种类,并且通过复制这些原型创建新的对象,属于创建型设计模式.

> **Specify the kinds of objects to create using a prototypical intance, and create new objects by copying this prototype.**

​	原型模式的核心在于复制原型对象.以系统中已存在的一个对象为原型,直接基于内存二进制流进行复制,不需要再经历耗时的对象初始化过程(不调用构造函数),性能提升许多.当对象的构建过程比较耗时的时候,可以把当前系统中已存在的对象作为原型,对其进行复制(一般是基于二进制流的复制),躲避初始化过程,使得对象的创建时间大大缩短.

### 4.5.2 原型模式使用场景

1. 创建对象成本较大(例如,初始化时间长,占用CPU太多,或者占用网络资源太多等)需要优化资源.
2. 创建一个对象需要繁琐的数据准备或访问权限等,需要提高性能或者提高安全性.
3. 系统中大量使用该类对象,且各个调用者都需要给它的属性重新复制.

### 4.5.3 原型模式UML类图

![1645271257713](images/proptotype.png)

原型模式主要包含3个角色:

1. **客户(Client)**: 客户提出创建对象的请求.
2. **抽象原型(IPrototype)**: 规定复制接口
3. **具体原型(ConcretePrototype)**: 被复制的对象

> **不是通过new关键字而是通过对象复制来实现创建对象的模式被称为原型模式**

### 4.5.4 原型模式扩展

#### 原型模式优点

1. Java自带的原型模式基于内存二进制流的复制,在性能上比直接new一个对象更加优良.
2. 可以使用深克隆方式保存对象的状态,使用原型模式将对象复制一份,并将其状态保存起来,简化了创建对象的过程,以便在需要的时候使用(例如恢复到历史某一状态),可辅助实现撤销操作.

#### 原型模式缺点

1. 需要为每一个类都配置一个clone方法.
2. clone方法位于类的内部,当对已有类进行改造时,需要修改代码,违背了开闭原则.
3. 当实现深克隆时候,需要编写较为复杂的代码,而且当对象之间存在多重嵌套引用时,为了实现深克隆,每一层对象对应的类都必须支持深克隆,实现起来比较麻烦.因此,深克隆,浅克隆需要运用得当.



## 4.6 建造者模式

### 4.6.1 建造者模式定义

​	建造者模式(Builder Pattern)将一个复杂对象的构建过程与它的表示分离,使得同样的构建过程可以创建不同的表示,属于创建型设计模式.

> **Separate the construction of a complex object from its representation so that the same construction process can create different representations.**

​	对于用户而言,使用建造者模式只需要指定需要创建的类型就可以获得对象,创建过程及细节不需要了解.根据建造者模式的定义,可以简单地理解为两层含义.

1. 构建与表示分离: 构建代表对象创建,表示代表对象行为,方法.也就是将对象的创建与行为进行分离(对应到Java代码,其实就是使用接口规定行为,然后由具体的实现进行构建)
2. 创建不同的表示: 也就是具备同样的行为,但是却由于构建的行为顺序不同或其他原因可以创建不同的表示.

### 4.6.2 建造者模式使用场景

1. 相同的方法,不同的执行顺序,产生不同的结果
2. 多个部件或零件,都可以装配到一个对象中,但是产生的结果又不相同
3. 产品类非常复杂,或者产品类中不同的调用顺序产生不同的作用
4. 初始化一个对象特别复杂,参数多,而且很多参数都具有默认值

### 4.6.3 建造者模式UML类图

![1645273210051](images/builder.png)

建造者模式主要包含4个角色:

1. **产品(Product)**: 要创建的产品类对象
2. **抽象建造者(IBuidler)**: 建造者的抽象类,规范产品对象的各个组成部分的创建,一般由子类实现具体的创建过程
3. **建造者(Concrete Builder)**: 具体的Builder类,根据不同的业务逻辑,具体化对象的各个组成部分的创建
4. **调用者(Director)**: 调用具体的建造者,来创建对象的各个部分,在指导者中不涉及具体产品的信息,只负责保证对象各部分完整创建或者按某种顺序创建,在类图中,Client相当于调用者的角色

### 4.6.4 建造者模式扩展

#### 建造者模式与工厂模式区别

1. 建造者模式更加注重方法的调用顺序,工厂模式注重创建对象
2. 创建对象的力度不同,建造者模式创建复杂的对象,由各种复杂的部件组成,工厂模式创建出来的对象都一样
3. 关注重点不一样,工厂模式只需要把对象创建出来就可以了,而建造者模式不仅要创建出对象,还要知道对象由哪些部件组成
4. 建造者模式根据建造过程中的顺序不一样,最终的对象部件组成不一样

#### 建造者模式优点

1. 封装性好,构建和表示分离
2. 扩展性好,建造类之间独立,在一定程度上解耦合
3. 便于控制细节,建造者可以对创建过程逐步细化,而不对其他模块产生任何影响

#### 建造者模式缺点

1. 需要多创建一个**IBuilder**对象
2. 如果产品内部发生变化,则建造者也要同步修改,后期维护成本较大



# 五. 结构型设计模式

## 5.1 代理模式

## 5.2 门面模式

## 5.3 装饰器模式

## 5.4 享元模式

## 5.5 组合模式

## 5.6 适配器模式

## 5.7 桥接模式



# 六. 行为型设计模式

## 6.1 委派模式

## 6.2 模板方法模式

## 6.3 策略模式

## 6.4 责任链模式

## 6.5 迭代器模式

## 6.6 命令模式

## 6.7 状态模式

## 6.8 备忘录模式

## 6.9 中介者模式

## 6.10 解释器模式

## 6.11 观察者模式

## 6.12 访问者模式